<html>

<head>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js"
          }
        }
      </script>
    <!-- <script src="//cdn.jsdelivr.net/gh/mrdoob/three.js@r151/build/three.js"></script> -->
    <script type="module">
        import * as THREE from "three";
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/GLTFLoader.js';

        var container;
        var camera, scene, renderer;
        var model;

        var model;

        var targetRotationX = 0.5;
        var targetRotationOnMouseDownX = 0;

        var targetRotationY = 0.2;
        var targetRotationOnMouseDownY = 0;

        var mouseX = 0;
        var mouseXOnMouseDown = 0;

        var mouseY = 0;
        var mouseYOnMouseDown = 0;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;

        var slowingFactor = 0.25;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerMove(event) {
            console.log('moved pointer');
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = (event.clientY / window.innerHeight) * 2 + 1;
        }

        window.addEventListener('mousemove', onPointerMove);

        init();

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.position.y = 150;
            camera.position.z = 500;
            scene.add(camera);

            // var materials = [];

            // for (var i = 0; i < 6; i++) {

            //     materials.push(new THREE.MeshBasicMaterial({
            //         color: Math.random() * 0xffffff
            //     }));

            // }
            const Loader = new GLTFLoader();
            Loader.load('../3d_models/3d_rack.glb', function (gltf) {


                const Material = new THREE.MeshStandardMaterial({
                    color: 'green', metalness: 0.1,
                    roughness: 0.5
                });


                model = gltf.scene;

                // Traverse the scene graph to find the specific mesh
                model.traverse((child) => {
                    // Set up click event listener
                    child.addEventListener('click', () => {
                        console.log('Clicked on:', child.name.toString());
                        // Add your desired functionality here
                    });

                    // console.log(child.name.toString());

                    if (child.isMesh && child.name === 'Node132') {
                        // Access the material of the mesh
                        child.material.color.set(0xff0000); // Set the color to red
                    }
                    if (child.isMesh && child.name === 'Node111') {
                        // Access the material of the mesh
                        child.material.color.set(0x00ff00); // Set the color to red
                    }
                });

                scene.add(model);


                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft white light
                scene.add(ambientLight);

                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Bright white light
                directionalLight.position.set(0, 1, 1).normalize(); // Position the light
                scene.add(directionalLight);

                animate();



            }, undefined, function (error) {
                console.error(error);
            });

            renderer = new THREE.WebGLRenderer({
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // const geometry = new THREE.BoxGeometry(100, 100, 100);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            // const cube = new THREE.Mesh(geometry, material);
            // scene.add(cube);

            container.appendChild(renderer.domElement);

            document.addEventListener('mousedown', onDocumentMouseDown, false);
        }

        function onDocumentMouseDown(event) {

            event.preventDefault();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            document.addEventListener('mouseout', onDocumentMouseOut, false);

            mouseXOnMouseDown = event.clientX - windowHalfX;
            targetRotationOnMouseDownX = targetRotationX;

            mouseYOnMouseDown = event.clientY - windowHalfY;
            targetRotationOnMouseDownY = targetRotationY;
        }

        function onDocumentMouseMove(event) {

            mouseX = event.clientX - windowHalfX;

            targetRotationX = (mouseX - mouseXOnMouseDown) * 0.00025;

            mouseY = event.clientY - windowHalfY;

            targetRotationY = (mouseY - mouseYOnMouseDown) * 0.00025;
        }

        function onDocumentMouseUp(event) {

            document.removeEventListener('mousemove', onDocumentMouseMove, false);
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
            document.removeEventListener('mouseout', onDocumentMouseOut, false);
        }

        function onDocumentMouseOut(event) {

            document.removeEventListener('mousemove', onDocumentMouseMove, false);
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
            document.removeEventListener('mouseout', onDocumentMouseOut, false);
        }

        function animate() {

            requestAnimationFrame(animate);

            render();


        }

        function render() {

            rotateAroundWorldAxis(model, new THREE.Vector3(0, 1, 0), targetRotationX);
            // rotateAroundWorldAxis(model, new THREE.Vector3(1, 0, 0), targetRotationY);

            targetRotationY = targetRotationY * (1 - slowingFactor);
            targetRotationX = targetRotationX * (1 - slowingFactor);

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if(intersects != null){
                console.log(intersects.length);
            }
            for (let i = 0; i < intersects.length; i++) {
                console.log(intersects[i].object.name.toString());
                intersects[i].object.material.color.set(0xff0000);

            }
            renderer.render(scene, camera);

        }


        function rotateAroundWorldAxis(object, axis, radians) {

            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationAxis(axis.normalize(), radians);
            rotationMatrix.multiply(object.matrix);                       // pre-multiply
            object.matrix = rotationMatrix;
            object.rotation.setFromRotationMatrix(object.matrix);
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
</body>

</html>